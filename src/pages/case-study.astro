---
import Layout from '../layouts/Layout.astro';
import Navigation from '../components/Navigation.astro';

// Process the markdown content dynamically
import markdownContentRaw from '../data/case-study-content.md?raw';

// Helper function to create section ID from title
function createSectionId(title: string): string {
  return title.toLowerCase()
    .replace(/\s+/g, '-')
    .replace(/[^a-z0-9-]/g, '')
    .replace(/^-+|-+$/g, '');
}

// Helper function to split content before a specific text (for 'before' position)
function splitContentBeforeText(content: string, searchText: string): [string, string] {
  // Normalize whitespace for better matching
  const normalizedSearch = searchText.replace(/\s+/g, ' ').trim();
  
  // Try exact match first
  let index = content.indexOf(searchText);
  
  // If not found, try case-insensitive match
  if (index === -1) {
    const lowerContent = content.toLowerCase();
    const lowerSearch = searchText.toLowerCase();
    index = lowerContent.indexOf(lowerSearch);
  }
  
  // If still not found, try with normalized whitespace
  if (index === -1) {
    const normalizedContent = content.replace(/\s+/g, ' ');
    index = normalizedContent.indexOf(normalizedSearch);
    if (index !== -1) {
      // Map back to original content - approximate position
      let originalIndex = 0;
      let normalizedPos = 0;
      for (let i = 0; i < content.length && normalizedPos < index; i++) {
        if (/\s/.test(content[i])) {
          if (normalizedPos < index) normalizedPos++;
        } else {
          normalizedPos++;
        }
        if (normalizedPos <= index) originalIndex = i + 1;
      }
      index = originalIndex;
    }
  }
  
  if (index === -1) {
    console.warn(`Text not found for 'before' position: "${searchText.substring(0, 50)}..."`);
    return [content, ''];
  }
  
  // Find the opening tag of the element containing this text
  const beforeText = content.substring(0, index);
  const lastOpenTag = beforeText.lastIndexOf('<');
  
  if (lastOpenTag === -1) {
    // No tag found, split at the text position
    return [
      content.substring(0, index),
      content.substring(index)
    ];
  }
  
  // Find the opening tag
  const tagMatch = beforeText.substring(lastOpenTag).match(/<(\w+)/);
  if (!tagMatch) {
    return [
      content.substring(0, index),
      content.substring(index)
    ];
  }
  
  // Split before the opening tag
  return [
    content.substring(0, lastOpenTag),
    content.substring(lastOpenTag)
  ];
}

// Helper function to split content at a specific text (for 'after' position)
function splitContentAtText(content: string, searchText: string): [string, string] {
  // Normalize whitespace for better matching
  const normalizedSearch = searchText.replace(/\s+/g, ' ').trim();
  
  // Try exact match first
  let index = content.indexOf(searchText);
  
  // If not found, try case-insensitive match
  if (index === -1) {
    const lowerContent = content.toLowerCase();
    const lowerSearch = searchText.toLowerCase();
    index = lowerContent.indexOf(lowerSearch);
  }
  
  // If still not found, try with normalized whitespace
  if (index === -1) {
    const normalizedContent = content.replace(/\s+/g, ' ');
    index = normalizedContent.indexOf(normalizedSearch);
    if (index !== -1) {
      // Map back to original content - approximate position
      let originalIndex = 0;
      let normalizedPos = 0;
      for (let i = 0; i < content.length && normalizedPos < index; i++) {
        if (/\s/.test(content[i])) {
          if (normalizedPos < index) normalizedPos++;
        } else {
          normalizedPos++;
        }
        if (normalizedPos <= index) originalIndex = i + 1;
      }
      index = originalIndex;
    }
  }
  
  if (index === -1) {
    console.warn(`Text not found: "${searchText.substring(0, 50)}..."`);
    return [content, ''];
  }
  
  // Find what element contains this text by looking backwards for the opening tag
  const beforeText = content.substring(0, index);
  const lastOpenTag = beforeText.lastIndexOf('<');
  let elementType = 'p'; // default
  
  if (lastOpenTag !== -1) {
    const tagMatch = beforeText.substring(lastOpenTag).match(/<(\w+)/);
    if (tagMatch) {
      elementType = tagMatch[1].toLowerCase();
    }
  }
  
  // Now look forward from the text to find the closing tag for this element
  const afterText = content.substring(index);
  const closingTagPattern = new RegExp(`</${elementType}>`, 'i');
  let match = afterText.match(closingTagPattern);
  
  if (!match) {
    // Fallback: look for any common closing tag
    const fallbackPattern = /<\/(p|h[1-4]|div|section|article|li)>/;
    match = afterText.match(fallbackPattern);
  }
  
  if (!match) {
    // Last resort: find next opening tag or end of content
    const nextTagMatch = afterText.match(/<[^/]/);
    if (nextTagMatch) {
      const splitPosition = index + nextTagMatch.index!;
      return [
        content.substring(0, splitPosition),
        content.substring(splitPosition)
      ];
    }
    // If no tag found, split at end of content
    return [content, ''];
  }
  
  const closingTagIndex = match.index! + match[0].length;
  const splitPosition = index + closingTagIndex;
  return [
    content.substring(0, splitPosition),
    content.substring(splitPosition)
  ];
}

// Diagram configuration for each section
const diagramConfig: Record<string, Array<{ text: string; src: string; alt: string; position: string; caption?: string }>> = {
  'Background': [
    { text: 'This unwelcome phenomenon is known as "hallucination".', src: '/diagrams/background-section/llm-training.svg', alt: 'LLM Training Diagram', position: 'after' },
    { text: 'while an unrelated term like "Piano" appears farther away.', src: '/diagrams/background-section/vectors-graph.svg', alt: 'Vectors Graph Diagram', position: 'after' },
    { text: 'Preparing a Document for RAG', src: '/diagrams/background-section/query-context-retrieval.png', alt: 'Query Context Retrieval Diagram', position: 'before' },
    { text: 'Doing this for one document is feasible.', src: '/diagrams/background-section/detailed-etl.svg', alt: 'Detailed ETL Diagram', position: 'before' },
  ],
  'Production RAG Pipelines': [
    { text: 'Multi-column layouts are read straight across from left to right, header hierarchies are flattened into plain text, and tables lose their row and column relationships.', src: '/diagrams/current-rag-landscape/bad-parsing.svg', alt: 'Bad Parsing Diagram', position: 'after' },
    
    { text: 'The algorithm rewards chunks that rank highly in both lists', src: '/diagrams/current-rag-landscape/keyword-vector-search.svg', alt: 'Keyword Vector Search Diagram', position: 'after' },
    { text: 'The output of the model is a relevance score, which is used to rerank the candidates and return the top results.', src: '/diagrams/current-rag-landscape/reranking.svg', alt: 'Reranking Diagram', position: 'after' },
  ],
  'Introducing Burrow': [
    { text: 'What Makes Burrow Unique?', src: '/diagrams/introducing-burrow/table.png', alt: 'Burrow Table Comparison', position: 'after' },
  ],
  'Walkthrough and Design': [
    { text: 'Hosted via CloudFront, it supports multiple users so teams can securely share pipeline access and connect scattered knowledge bases.', src: '/diagrams/introducing-burrow/ui.png', alt: 'Burrow UI Dashboard', position: 'after' },
    { text: 'Structured JSON is used to preserve key information about the document\'s hierarchical structure, such as filename, page numbers, and element types, as metadata.', src: '/diagrams/introducing-burrow/docling.svg', alt: 'Docling Diagram', position: 'after', caption: 'Docling\'s parsing workflow' },
    { text: 'Optional parameters allow developers to control retrieval behavior, enabling or tuning techniques such as hybrid search, reranking, and metadata filtering as needed:', src: '/diagrams/introducing-burrow/code-snippet.png', alt: 'Code Snippet', position: 'after', caption: 'For more details, see the <a href="/docs">API documentation</a>' },
    { text: 'A simple command-line interface allows users to easily deploy Burrow to their AWS infrastructure and get started with their pipeline.', src: '/diagrams/introducing-burrow/cli-output.png', alt: 'CLI Output', position: 'after' },
  ],
  'Building Burrow': [
    { text: 'This diagram shows how Burrow’s core functions are implemented using AWS services.', src: '/diagrams/architecture/legend.svg', alt: 'Architecture Legend', position: 'after' },
    { text: 'RAG API', src: '/diagrams/architecture/high-level.svg', alt: 'High-Level Architecture', position: 'after' },
    { text: 'CloudFront functions as a secure entry point to Burrow\'s pipeline: it routes API traffic to the Application Load Balancer while serving the web UI as a single-page application.', src: '/diagrams/architecture/file-upload.svg', alt: 'File Upload Architecture', position: 'before' },
    { text: 'Event-Driven Triggers', src: '/diagrams/architecture/event-driven.svg', alt: 'Event-Driven Architecture', position: 'after' },
    { text: 'Ingestion Task', src: '/diagrams/architecture/ingestion.svg', alt: 'Ingestion Architecture', position: 'after' },
    { text: 'Vector Store', src: '/diagrams/architecture/indexes.svg', alt: 'Vector Store Indexes', position: 'after' },
    { text: 'The RAG API is an ECS service that handles all retrieval operations - we discuss the decision to separate it from the pipeline API below in Engineering Challenges.', src: '/diagrams/architecture/rag-api.svg', alt: 'RAG API Architecture', position: 'before' },
  ],
  'Engineering Tradeoffs and Challenges': [
    { text: 'The cost-savings angle, however, made this an easy decision: we estimate a 95%+ reduction in costs with this approach compared to always-on infrastructure.', src: '/diagrams/challenges/service-vs-task.svg', alt: 'Service vs Task Comparison', position: 'after' },
    { text: 'The document is then moved to a "deleted" folder in S3 with a 90-day lifecycle policy, and a time to live (TTL) of 90 days is added to the document in DynamoDB.', src: '/diagrams/challenges/transaction-prob.svg', alt: 'Transaction Problem Diagram', position: 'after' },
  ],
};

// Convert markdown to HTML
function processMarkdownContent(content: string, sectionId: string): string {
  return content
    // Convert subsection headers with IDs
    .replace(/^## (.+)$/gm, (match, headerTitle) => {
      const subsectionId = `${sectionId}-${createSectionId(headerTitle)}`;
      return `<h3 id="${subsectionId}">${headerTitle}</h3>`;
    })
    // Convert sub-subsection headers
    .replace(/^### (.+)$/gm, '<h4>$1</h4>')
    // Convert markdown links
    .replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2">$1</a>')
    // Convert images
    .replace(/!\[([^\]]*)\]\(([^)]+)\)/g, '<img src="$2" alt="$1" class="content-image" />')
    // Convert bold text
    .replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')
    // Convert paragraphs - split by double newlines first
    .split('\n\n')
    .map(block => {
      block = block.trim();
      if (!block) return '';

      // Check if this block is a numbered list
      const lines = block.split('\n');
      const isNumberedList = lines.length > 0 && /^\d+\./.test(lines[0].trim());
      const isUnorderedList = lines.length > 0 && /^-/.test(lines[0].trim());

      if (isNumberedList) {
        // Convert numbered list items
        const listItems = lines
          .filter(line => /^\d+\./.test(line.trim()))
          .map(line => {
            const content = line.replace(/^\d+\. (.+)$/, '$1');
            // Process links in list items
            const withLinks = content.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2">$1</a>');
            return '<li>' + withLinks + '</li>';
          })
          .join('');
        return '<ol>' + listItems + '</ol>';
      } else if (isUnorderedList) {
        // Convert unordered list items
        const listItems = lines
          .filter(line => /^-/.test(line.trim()))
          .map(line => {
            const content = line.replace(/^- (.+)$/, '$1');
            // Process links in list items
            const withLinks = content.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2">$1</a>');
            return '<li>' + withLinks + '</li>';
          })
          .join('');
        return '<ul>' + listItems + '</ul>';
      }
      if (block.includes('<h3>') || block.includes('<h4>')) {
        return block;
      }
      if (block.includes('<img')) {
        return block;
      }
      return '<p>' + block.replace(/\n/g, ' ') + '</p>';
    })
    .join('\n');
}

// Split content based on diagram configuration
function splitContentForDiagrams(content: string, title: string): { parts: string[]; diagrams: Array<{ src: string; alt: string; caption?: string }> } {
  const config = diagramConfig[title];
  if (!config || config.length === 0) {
    return { parts: [content], diagrams: [] };
  }

  const parts: string[] = [];
  const diagrams: Array<{ src: string; alt: string; caption?: string }> = [];
  let remainingContent = content;

  for (const diagram of config) {
    if (title === 'Building Burrow') {
      console.log(`Searching for diagram "${diagram.alt}" with text: "${diagram.text.substring(0, 60)}..."`);
      console.log(`Remaining content length: ${remainingContent.length}`);
      console.log(`Text found in remaining content: ${remainingContent.includes(diagram.text) || remainingContent.toLowerCase().includes(diagram.text.toLowerCase())}`);
    }
    
    if (diagram.position === 'before') {
      // For 'before', split before the text
      const [before, after] = splitContentBeforeText(remainingContent, diagram.text);
      if (after) {
        parts.push(before);
        diagrams.push({ src: diagram.src, alt: diagram.alt, caption: diagram.caption });
        remainingContent = after;
        if (title === 'Building Burrow') {
          console.log(`✓ Found and split for "${diagram.alt}"`);
        }
      } else {
        // If we can't find the text, log a warning but continue
        console.warn(`Could not find text for diagram "${diagram.alt}" in section "${title}": "${diagram.text.substring(0, 50)}..."`);
        // Don't break - continue processing other diagrams
      }
    } else {
      // For 'after' (default), split after the text
      const [before, after] = splitContentAtText(remainingContent, diagram.text);
      if (after) {
        parts.push(before);
        diagrams.push({ src: diagram.src, alt: diagram.alt, caption: diagram.caption });
        remainingContent = after;
        if (title === 'Building Burrow') {
          console.log(`✓ Found and split for "${diagram.alt}"`);
        }
      } else {
        // If we can't find the text, log a warning but continue
        console.warn(`Could not find text for diagram "${diagram.alt}" in section "${title}": "${diagram.text.substring(0, 50)}..."`);
        if (title === 'Building Burrow') {
          console.warn(`Remaining content snippet: ${remainingContent.substring(0, 200)}...`);
        }
        // Don't break - continue processing other diagrams
      }
    }
  }

  // Add remaining content as the last part
  if (remainingContent) {
    parts.push(remainingContent);
  }

  return { parts, diagrams };
}

// Parse the markdown content into sections
const rawSections = markdownContentRaw.split(/^# /gm);
console.log('Total raw sections found:', rawSections.length);

const sections = rawSections
  .slice(1)
  .filter(section => section.trim())
  .map((section, index) => {
    const lines = section.split('\n');
    const title = lines[0].trim();
    console.log(`Processing section ${index + 1}: "${title}"`);
    let content = lines.slice(1).join('\n').trim();

    const id = createSectionId(title);

    // Extract subsections
    const subsections = [];
    try {
      const subsectionPattern = /^## (.+)$/gm;
      let match;
      const subsectionMatches = [];

      while ((match = subsectionPattern.exec(content)) !== null) {
        subsectionMatches.push({
          title: match[1],
          index: match.index
        });
      }

      subsectionMatches.forEach((match, subIndex) => {
        const subsectionId = `${id}-${createSectionId(match.title)}`;
        subsections.push({
          title: match.title,
          id: subsectionId,
          number: `${index + 1}.${subIndex + 1}`
        });
      });
    } catch (error) {
      console.error(`Error processing subsections for section "${title}":`, error);
    }

    // Process markdown to HTML
    let processedContent = '';
    let contentParts: string[] = [];
    let diagrams: Array<{ src: string; alt: string; caption?: string }> = [];

    try {
      processedContent = processMarkdownContent(content, id);
      const splitResult = splitContentForDiagrams(processedContent, title);
      contentParts = splitResult.parts;
      diagrams = splitResult.diagrams;
    } catch (error) {
      console.error(`Error processing content for section "${title}":`, error);
      processedContent = `<p>Error processing content for section: ${title}</p>`;
      contentParts = [processedContent];
      diagrams = [];
    }

    return {
      id,
      title,
      contentParts,
      diagrams,
      subsections,
      number: index + 1
    };
  });

console.log('Final sections array:');
console.log('Total sections:', sections.length);
sections.forEach((section, index) => {
  console.log(`${index + 1}. ${section.title} (${section.subsections.length} subsections)`);
});

---

<Layout title="Burrow - Case Study" description="Detailed case study of the Burrow project">
  <Navigation />
  <main class="case-study-main">
    <div class="case-study-container">
      <!-- Sidebar Navigation -->
      <aside class="sidebar">
        <nav class="case-study-nav">
          <ul class="direct-sections">
            {sections.map((section) => (
              <li class="section-item">
                  <div class="sidebar-main-section-container">
                    <a href={`#${section.id}`} class="sidebar-main-section">{section.title}</a>
                    {section.subsections && section.subsections.length > 0 && (
                      <button class="subsection-toggle" data-section-id={section.id}>
                        <span class="subsection-arrow">▶</span>
                      </button>
                    )}
                  </div>
                  {section.subsections && section.subsections.length > 0 && (
                    <ul class="sidebar-nav-sub-subsections" id={`subsections-${section.id}`}>
                    {section.subsections.map((subsection) => (
                      <li>
                        <a href={`#${subsection.id}`} class="sidebar-subsection">{subsection.title}</a>
                      </li>
                      ))}
                    </ul>
                  )}
                </li>
            ))}
          </ul>
        </nav>
      </aside>

      <!-- Main Content -->
      <article class="content">
        {sections.map(section => (
          <section id={section.id} class="content-section">
            <h2>{section.title}</h2>
            
            {/* Render content parts with diagrams interspersed */}
            {section.contentParts.map((part, partIndex) => (
              <>
                <div class="content-body" set:html={part}></div>
                {partIndex < section.diagrams.length && (
                  <div class="diagram-container">
                    <img src={section.diagrams[partIndex].src} alt={section.diagrams[partIndex].alt} class="diagram" />
                    {section.diagrams[partIndex].caption && (
                      <p class="diagram-caption" set:html={section.diagrams[partIndex].caption}></p>
                    )}
                  </div>
                )}
              </>
            ))}

            {/* Special case: Add full architecture diagram at the end of Building Burrow section */}
            {section.id === 'building-burrow' && (
              <div class="diagram-container">
                <img src="/diagrams/architecture/full.svg" alt="Full Architecture Diagram" class="diagram" />
              </div>
            )}

          </section>
        ))}
      </article>
    </div>
  </main>
</Layout>

<style>
/* Case Study Layout */
.case-study-main {
  background: white;
  min-height: 100vh;
  color: #333 !important;
  padding-top: 100px;
  margin-top: 0;
}

.case-study-main * {
  color: inherit !important;
}

.case-study-container {
  display: grid;
  grid-template-columns: 320px 1fr;
  max-width: 1200px;
  margin: 0 auto;
  gap: 0;
}

/* Sidebar Navigation */
.sidebar {
  position: sticky;
  top: 100px;
  height: calc(100vh - 100px);
  max-height: calc(100vh - 100px);
  background: #ffffff;
  border-right: 1px solid #e9ecef;
  overflow-y: auto;
  overflow-x: hidden;
  display: flex;
  flex-direction: column;
  padding: 0;
  box-shadow: 2px 0 8px rgba(0, 0, 0, 0.04);
}

.sidebar::-webkit-scrollbar {
  width: 6px;
}

.sidebar::-webkit-scrollbar-track {
  background: transparent;
}

.sidebar::-webkit-scrollbar-thumb {
  background: rgba(0, 105, 148, 0.2);
  border-radius: 3px;
}

.sidebar::-webkit-scrollbar-thumb:hover {
  background: rgba(0, 105, 148, 0.35);
}

.case-study-nav {
  flex: 1 1 auto;
  overflow: visible;
  padding: 1.5rem 0 3rem 0;
  min-height: 0;
  width: 100%;
  position: relative;
}

.direct-sections {
  list-style: none;
  margin: 0;
  padding: 0 0.75rem;
}

.section-item {
  margin: 0.5rem 0;
}

.sidebar-main-section-container {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 0.625rem 1.25rem 0.625rem 1rem;
  border-left: 3px solid transparent;
  border-radius: 0 6px 6px 0;
  transition: all 0.2s ease;
  position: relative;
}

.sidebar-main-section-container::before {
  content: '';
  position: absolute;
  left: 0;
  top: 0;
  bottom: 0;
  width: 3px;
  background: #006994;
  transform: scaleY(0);
  transition: transform 0.2s ease;
}

.sidebar-main-section-container:hover {
  background: rgba(0, 105, 148, 0.06);
  transform: translateX(4px);
}

.sidebar-main-section-container:hover::before {
  transform: scaleY(1);
}

.sidebar-main-section {
  font-weight: 600;
  font-size: 1rem;
  color: #4E342E;
  flex: 1;
  text-decoration: none;
  transition: color 0.2s ease;
}

.sidebar-main-section:hover {
  color: #006994;
}

.subsection-toggle {
  background: none;
  border: none;
  cursor: pointer;
  padding: 0.25rem;
  margin-left: 0.5rem;
  border-radius: 3px;
  transition: all 0.2s ease;
}

.subsection-toggle:hover {
  background: rgba(0, 105, 148, 0.1);
}

.subsection-arrow {
  font-size: 0.7rem;
  color: #6B5B47;
  transition: transform 0.3s ease;
}

.subsection-toggle.expanded .subsection-arrow {
  transform: rotate(90deg);
}

.sidebar-nav-sub-subsections {
  list-style: none;
  margin: 0.25rem 0;
  padding: 0;
  padding-left: 0.75rem;
  border-left: 1px solid rgba(0, 105, 148, 0.1);
  margin-left: 2rem;
  max-height: 0;
  overflow: hidden;
  transition: max-height 0.4s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.3s ease;
  opacity: 0;
}

.sidebar-nav-sub-subsections.expanded {
  max-height: 500px;
  overflow: visible;
  opacity: 1;
}

.sidebar-nav-sub-subsections li {
  margin: 0.125rem 0;
}

.sidebar-nav-sub-subsections a {
  color: #8A7968;
  text-decoration: none;
  font-size: 0.9rem;
  line-height: 1.4;
  display: block;
  padding: 0.5rem 1rem 0.5rem 1.25rem;
  transition: all 0.2s ease;
  border-left: 2px solid transparent;
  border-radius: 0 4px 4px 0;
  font-weight: 400;
}

.sidebar-nav-sub-subsections a:hover {
  color: #006994;
  background: rgba(0, 105, 148, 0.05);
  border-left-color: #006994;
  transform: translateX(2px);
}

.sidebar-nav-sub-subsections a.sidebar-subsection {
  padding-left: 1.5rem;
}

/* Main Content */
.content {
  padding: 2rem 3rem;
  max-width: 100%;
  position: relative;
  z-index: 1;
  box-sizing: border-box;
  overflow-x: hidden;
}

.content-section {
  margin-bottom: 4rem;
  scroll-snap-align: start;
  scroll-snap-stop: always;
  scroll-margin-top: 100px;
  overflow-x: hidden;
  word-wrap: break-word;
  max-width: 100%;
  box-sizing: border-box;
}

.content-section h2 {
  color: #4E342E;
  font-size: 2rem;
  font-weight: 600;
  margin: 0 0 1.5rem 0;
  padding-top: 2rem;
  border-top: 1px solid #f0f0f0;
}

.content-section:first-of-type h2 {
  border-top: none;
  padding-top: 0;
}

.content-section p {
  color: #6B5B47 !important;
  font-size: 1.9rem;
  line-height: 1.7;
  margin-bottom: 1.5rem;
  max-width: 100%;
  overflow-wrap: break-word;
  word-wrap: break-word;
  box-sizing: border-box;
}

.content-section h3 {
  color: #4E342E !important;
  font-size: 1.5rem;
  font-weight: 600;
  margin: 2rem 0 1rem 0;
}

.content-section h4 {
  color: #4E342E !important;
  font-size: 1.25rem;
  font-weight: 600;
  margin: 1.5rem 0 0.75rem 0;
}

.content-section ul {
  color: #6B5B47 !important;
  font-size: 1.9rem;
  line-height: 1.7;
  margin-bottom: 1.5rem;
  padding-left: 1.5rem;
}

.content-section li {
  color: #6B5B47 !important;
  font-size: 1.9rem;
  margin-bottom: 0.5rem;
}

.content-section strong {
  color: #4E342E !important;
  font-weight: 600;
}

.content-section a,
.content-body a {
  color: #006994 !important;
  text-decoration: underline !important;
}

.content-section a:hover,
.content-body a:hover {
  color: #005a7a !important;
}

.content-section div p {
  color: #6B5B47 !important;
}

.content-section div h3 {
  color: #4E342E !important;
}

.content-section div h4 {
  color: #4E342E !important;
}

.content-section div ul {
  color: #6B5B47 !important;
}

.content-section div li {
  color: #6B5B47 !important;
}

.content-section div strong {
  color: #4E342E !important;
}

.content-body {
  overflow-x: hidden;
  max-width: 100%;
  box-sizing: border-box;
  min-width: 0;
}

.content-section div {
  overflow-x: hidden;
  max-width: 100%;
  box-sizing: border-box;
  min-width: 0;
}

.diagram-container {
  width: 100%;
  max-width: 100%;
  margin: 2rem 0;
  box-sizing: border-box;
  display: block;
  min-width: 0;
  overflow: visible;
}

.diagram-container img,
.diagram {
  display: block;
  max-width: 100% !important;
  width: 100% !important;
  height: auto !important;
  box-sizing: border-box;
  border-radius: 8px;
  min-width: 0;
  object-fit: contain;
  image-rendering: auto;
  vertical-align: middle;
}

.content-image {
  display: block;
  max-width: 100%;
  width: 100%;
  height: auto;
  border-radius: 8px;
  box-sizing: border-box;
}

.content-section img[src$=".svg"],
.content-image[src$=".svg"] {
  max-width: 100% !important;
  width: 100% !important;
  height: auto !important;
  display: block !important;
  box-sizing: border-box !important;
  min-width: 0 !important;
  object-fit: contain !important;
}

.content-section .diagram-container,
.content-body .diagram-container,
.content-section div .diagram-container {
  overflow: visible !important;
  max-width: 100% !important;
  width: 100% !important;
  min-width: 0 !important;
  box-sizing: border-box !important;
}

.content-body .diagram-container img,
.content-body .diagram-container .diagram,
.content-section div .diagram-container img,
.content-section div .diagram-container .diagram {
  max-width: 100% !important;
  width: 100% !important;
  height: auto !important;
  box-sizing: border-box !important;
  min-width: 0 !important;
  object-fit: contain !important;
}

.content-section pre {
  background: #f1f3f4;
  border: 1px solid #e1e4e8;
  border-radius: 6px;
  padding: 1rem;
  overflow-x: auto;
  margin: 1.5rem 0;
  font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
  font-size: 1rem;
  line-height: 1.5;
}

.content-section code {
  background: #f1f3f4;
  padding: 0.2rem 0.4rem;
  border-radius: 3px;
  font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
  font-size: 1em;
  color: #d73a49;
}

.content-section pre code {
  background: none;
  padding: 0;
  color: #24292e;
  font-size: 1rem;
}

.diagram-container .diagram-caption,
.diagram-caption {
  color: #6B5B47 !important;
  font-size: 0.95rem !important;
  text-align: center !important;
  margin-top: 0.5rem !important;
  font-style: italic !important;
  line-height: 1.4 !important;
}

.diagram-caption a {
  color: #006994 !important;
  text-decoration: underline !important;
}

.diagram-caption a:hover {
  color: #005a7a !important;
}

@media (max-width: 768px) {
  .case-study-container {
    grid-template-columns: 1fr;
    gap: 0;
    padding: 0;
  }

  .sidebar {
    display: none;
  }

  .content {
    padding: 1.5rem;
  }

  .content-section h2 {
    font-size: 2rem;
  }
}

/* API Documentation Styles */
.api-section {
  margin-top: 2rem;
}

.api-section h3 {
  color: #4E342E;
  margin: 2rem 0 1rem 0;
  font-size: 1.3rem;
  border-bottom: 2px solid #e9ecef;
  padding-bottom: 0.5rem;
}

.endpoint-group {
  margin: 2rem 0;
  border: 1px solid #e9ecef;
  border-radius: 8px;
  overflow: hidden;
}

.endpoint-path {
  background: #f8f9fa;
  padding: 1rem;
  margin: 0;
  border-bottom: 1px solid #e9ecef;
  font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
  font-size: 1rem;
}

.endpoint {
  padding: 1.5rem;
  border-bottom: 1px solid #f0f0f0;
}

.endpoint:last-child {
  border-bottom: none;
}

.endpoint-header {
  display: flex;
  align-items: center;
  gap: 1rem;
  margin-bottom: 1rem;
}

.method {
  color: white;
  padding: 0.25rem 0.75rem;
  border-radius: 4px;
  font-size: 0.8rem;
  font-weight: bold;
  text-transform: uppercase;
  font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
}

.method-get {
  background: #28a745;
}

.method-post {
  background: #007bff;
}

.method-delete {
  background: #dc3545;
}

.endpoint-summary {
  font-weight: 600;
  color: #4E342E;
}

.endpoint-description {
  color: #6B5B47;
  margin: 1rem 0;
}

.parameters-section, .request-section, .responses-section {
  margin: 1.5rem 0;
}

.parameters-list {
  list-style: none;
  padding: 0;
  margin: 0.5rem 0;
}

.parameters-list li {
  padding: 0.5rem 0;
  border-bottom: 1px solid #f0f0f0;
}

.param-type {
  color: #6B5B47;
  font-size: 0.9rem;
  margin-left: 0.5rem;
}

.param-schema {
  background: #e9ecef;
  padding: 0.2rem 0.4rem;
  border-radius: 3px;
  font-size: 0.8rem;
  margin-left: 0.5rem;
  font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
}

.param-description {
  color: #6B5B47;
  margin-left: 0.5rem;
}

.response {
  margin: 1rem 0;
  padding: 1rem;
  background: #f8f9fa;
  border-radius: 6px;
}

.status-code {
  font-weight: bold;
  margin: 0 0 0.5rem 0;
}

.status-2 {
  color: #28a745;
}

.status-4 {
  color: #dc3545;
}

.api-section pre {
  background: #f1f3f4;
  border: 1px solid #e1e4e8;
  border-radius: 6px;
  padding: 1rem;
  overflow-x: auto;
  margin: 1rem 0;
  font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
  font-size: 1rem;
  line-height: 1.4;
}

.api-section code {
  background: #f1f3f4;
  padding: 0.2rem 0.4rem;
  border-radius: 3px;
  font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
  font-size: 1em;
  color: #d73a49;
}

</style>

<style is:global>
  html {
    scroll-snap-type: y mandatory;
    scroll-behavior: smooth;
    overflow-y: scroll;
  }
  
  body {
    scroll-snap-type: y mandatory;
  }
</style>

<script>
document.addEventListener('DOMContentLoaded', function() {
  const subsectionToggles = document.querySelectorAll('.subsection-toggle');
  subsectionToggles.forEach(toggle => {
    const sectionId = toggle.getAttribute('data-section-id');
    const subsectionsList = document.getElementById(`subsections-${sectionId}`);

    if (subsectionsList) {
      subsectionsList.classList.remove('expanded');
    }

    toggle.addEventListener('click', function(e) {
      e.preventDefault();
      e.stopPropagation();
      toggleSubsectionList(sectionId);
    });
  });
});

function toggleSubsectionList(sectionId) {
  const toggle = document.querySelector(`[data-section-id="${sectionId}"]`);
  const subsectionsList = document.getElementById(`subsections-${sectionId}`);

  if (toggle && subsectionsList) {
    const isExpanded = toggle.classList.contains('expanded');

    if (isExpanded) {
      toggle.classList.remove('expanded');
      subsectionsList.classList.remove('expanded');
    } else {
      toggle.classList.add('expanded');
      subsectionsList.classList.add('expanded');
    }
  }
}
</script>
